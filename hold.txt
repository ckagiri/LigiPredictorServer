{
  "name": "LigiPredictorServer",
  "version": "1.0.0",
  "description": "Ligi Predictor Server",
  "main": "server.js",
  "scripts": {
    "tsc": "tsc",
    "tsc:w": "tsc -w",
    "mongodb": "mongod --dbpath=C:/data/db --port 27017",
    "server": "node src/server.js",
    "start": "concurrently \"npm run tsc:w\" \"nodemon src/server.js\"",
    "db:drop": "SET NODE_ENV=development&&node src/db/tasks/drop.js",
    "db:seed": "SET NODE_ENV=development&&node src/db/tasks/seed.js",
    "db:test:dropseed": "SET NODE_ENV=test&&node src/db/tasks/drop-seed.js",
    "db:dev:dropseed": "SET NODE_ENV=development&&node src/db/tasks/drop-seed.js",
    "db:reset": "SET NODE_ENV=development&&node src/db/tasks/reset.js",
    "test": "mocha --reporter spec --compilers ts:ts-node/register src/**/*.spec.ts",
    "test:mocha": "mocha --reporter spec --compilers ts:ts-node/register src/**/*.test.ts",
    "mocha": "node node_modules/mocha/bin/mocha  --reporter spec src/db/**/*.test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ckagiri/LigiPredictorServer.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/ckagiri/LigiPredictorServer/issues"
  },
  "homepage": "https://github.com/ckagiri/LigiPredictorServer#readme",
  "engines": {
    "node": ">=4.6.x",
    "npm": ">=2.15.x"
  },
  "dependencies": {
    "bluebird": "^3.4.7",
    "body-parser": "1.15.2",
    "express": "4.14.0",
    "lodash": "4.16.6 ",
    "mongoose": "4.6.7",
    "path": "0.12.7",
    "request": "^2.79.0",
    "request-promise": "^4.1.1",
    "rxjs": "^5.0.2",
    "serve-favicon": "2.3.2"
  },
  "devDependencies": {
    "@types/async": "2.0.37",
    "@types/body-parser": "0.0.33",
    "@types/chai": "^3.4.34",
    "@types/express": "4.0.34",
    "@types/lodash": "4.14.39",
    "@types/mocha": "2.2.33",
    "@types/mongoose": "4.5.42",
    "@types/request-promise": "^4.1.33",
    "@types/supertest": "1.1.32",
    "async": "2.1.4",
    "chai": "3.5.0",
    "concurrently": "3.1.0",
    "mocha": "3.2.0",
    "mongoose-seeder": "^1.2.1",
    "supertest": "2.0.1",
    "ts-node": "^1.7.0",
    "typescript": "2.0.10"
  }
}


choice {
goalsHomeTeam reqd
goalsAwayTeam reqd
}
user ref: 'User' reqd,
fixture: ref: 'Fixture' reqd
timestamp: Date.now()
points

	
Score
user
tournament
fixture
prediction
points
pointsold
posold
posnew


User
slackUname
scores
predictions

$matches = Matches.getFinishedNotScored();
$users = User.getAllEnabled();
foreach ($users as $user) {
  $scores = Score.getByUser($user)
  $predictions = Prediction.getFinishedNotScored($user);
  foreach ($predictions as $prediction) {
    $matchId = $prediction->getMatchId;
    $match = $matches[$matchId];
    $predictionPoints = $prediction->calculatePoints($match);
    $prediction->setPoints($predictionPoints);
    $prediction->setScoreAdded('1');
    $this->em->persist($prediction);
    $tournament = $match->getTournamentId();
    if (!in_array($tournament, $tournamentsModified)) {
      $tournamentsModified[] = $tournament;
      $tournamentScores = Score.getByTournamentOrderByPosNew($tournament);
      // keep all users' previous points
      foreach ($tournamentScores as $score) {
        $previousPoints = $score->getPoints();
        $score->setPointsOld($previousPoints);
        // prepare queries
        $this->em->persist($score);
      }
    }
    if ($predictionPoints > 0) {
      $scores[$tournament->getId()]->updatePoints($predictionPoints);
      // prepare the queries
      $this->em->persist($scores[$tournament->getId()]);
    }
  }
}

calculateUserPositions(&$tournamentsModified)
{
  foreach ($tournamentsModified as $tournament) {
    $scores = Score.getByTournamentOrderByPoints($tournament);
    $position = 0;
    foreach ($scores as &$score) {
      $position = $position + 1;
      $previousPosition = $score->getPosNew();
      $score->setPosOld($previousPosition);
      $score->setPosNew($position);
      // prepare the queries
      $this->em->persist($score);
    }
  }
  // execute the queries
  $this->em->flush();
}

function getPrediction(User $user, Match $match, array $predictions)
if (isset($predictions[$match->getId()])) {
  // link/merge prediction with EntityManager (set entity as managed by EM)
  $prediction = $this->em->merge($predictions[$match->getId()]);
} else {
  $prediction = new Prediction();
  $prediction->setMatchId($match);
  $prediction->setUserId($user);
}
return $prediction;
}

$matches = Match').getNotScored($user, $urlParams['tournament_id'], $urlParams['date_from'], $modifiedDateTo)
$predictions = Prediction.getNotScored($user, $urlParams['tournament_id'], $urlParams['date_from'], $modifiedDateTo);
$matchForms = array();
if ($matches) {
  $matchForms = $this->createMatchForms($request, $urlParams, $matchesHelper, $user, $matches, $predictions);
}
function createMatchForms($request, $urlParams, $matchesHelper, $user, $matches, $predictions)
  $matchForms = array();
  // creating a form with BET/EDIT button for each match
  foreach ($matches as $match) {
    //if match has started set disabled to true
    if ($match->hasStarted()) $match->setDisabledAttribute();
    $prediction = $matchesHelper->getPrediction($user, $match, $predictions);
    $buttonAction = $matchesHelper->getPredictionButton($prediction);
    $form = $matchesHelper->createForm($request, $urlParams, $match, $prediction, $buttonAction);
    // create view for each form
    $form = $form->createView();
    $matchForms[$match->getId()] = $form;
  }
  return $matchForms;
}


$formsArray = $get('matches');
foreach ($formsArray as $submittedForm) {
  $match = Match.findOneById($submittedForm['matchId']);
  // skip to next form if this match has started or data is invalid
  if ($match->hasStarted() ||
    !(is_numeric($submittedForm['homeGoals']) && $submittedForm['homeGoals'] >= 0) ||
    !(is_numeric($submittedForm['awayGoals']) && $submittedForm['awayGoals'] >= 0))
      continue;
    // prepare the Prediction object (new or modified one) for persisting in DB
    if ($submittedForm['action'] === 'BET') {
      $prediction = new Prediction(); 
      $prediction->setUserId($user);
      $prediction->setMatchId($match);
      $prediction->setHomeGoals($submittedForm['homeGoals']);
      $prediction->setAwayGoals($submittedForm['awayGoals']);
    } elseif ($submittedForm['action'] === 'EDIT') {
      $prediction = Prediction.getOneByUserAndMatch($user, $match);
      $prediction->setHomeGoals($submittedForm['homeGoals']);
      $prediction->setAwayGoals($submittedForm['awayGoals']);
    }
  }


exports.list = function(req, res) { 
	console.log(req.user);
	var start = Date.now();
	Fixture
	.find()
	.lean()
	.sort('date')
	.populate('homeTeam')
	.populate('awayTeam')
	.populate('result')
	.exec(function(err,fixtures){
		if(err) {
			return res.status(400).send({
				message: errorHandler.getErrorMessage(err)
			});
		} else {
			Prediction
			.find({user:req.user})
			.populate('user')
			.lean()
			.exec(function(err,predicions){
				Score
				.find({user:req.user})
				.lean()
				.exec(function(err,scores){
					predicions.forEach(function(prediction){
						fixtures.forEach(function(fixture){
							if(fixture._id === prediction.fixture) {
								fixture.prediction = prediction;
							}
							if(fixture.date < start) {
								fixture.predictionDisabled = true;
							}
						});
						scores.forEach(function(score){
							if(score.fixture === prediction.fixture) {
								prediction.score = score;
							}
						});
					});
					var end = Date.now();
					var time = end - start;
					console.log('Query took '+time+' milliseconds to run');
					res.jsonp(fixtures);
				});						
			});
		}
	});
};

exports.my = function(req,res){
	Prediction
		.find({user: req.user})
		.lean()
		.populate('user')
		.populate('fixture')
		.sort('-created')
		.exec(function(err,predictions){
			var opts = {
				path: 'fixture.homeTeam fixture.awayTeam',
				model: 'Team'
			};
			Prediction.populate(predictions,opts,function(err,predictions){
				res.jsonp(predictions);
			});
		});
};

exports.create = function(req, res) {
	var calcResult = function(home,away){
		if(home > away){
			return 'w';
		}
		if(home < away){
			return 'l';
		}
		if(home === away){
			return 'd';
		}
	};
	var predictions = req.body;
	var arr = [];
	for(var key in predictions){
		var prediction = {
			goalsHomeTeam: predictions[key].goalsHomeTeam,
			goalsAwayTeam: predictions[key].goalsAwayTeam,
			user: req.user._id,
			result: calcResult(predictions[key].goalsHomeTeam,predictions[key].goalsAwayTeam),
			fixture: key
		};
		arr.push(prediction);
	}
	console.log(arr);
	Prediction.create(arr,function(err){
		if(err){
			console.log(err);
		} else {
			console.log('Save ok');
		}
	});
	res.jsonp(predictions);
};

function processGambleWithBetsOnEvent(Event $event)
{
	// Select all gambles having the event in its bets
	$gambles = findAllGambleHavingBetsOnEvent($event);
	foreach ($gambles as $gamble) {
		$this->processor->process($gamble, $event, $this->date);
	}
}

interface GambleProcessorInterface
{
	public function process(Gamble $gamble, Event $event, \DateTime $date);
	public function apply(Gamble $gamble);
}

class GambleProcessor
{
	protected $processors;
	protected $logger;

	function process(Gamble $gamble, Event $event, \DateTime $date)
	{
		foreach ($this->processors as $process) {
			if (!$process->apply($gamble)) {
				$this->log('Gamble  #'.$gamble->getId().' : processor '.get_class($process).' not applied');
				continue;
			}
			$process->process($gamble, $event, $date);
		}
	}
}

CompleteGambleProcessor implements GambleProcessorInterface
{
	public CalculatorInterface $calculator)
	{
		$this->calculator = $calculator;
	}

	process(Gamble $gamble, Event $event, \DateTime $date)
	{
		// Fill the winner field in the gamble according to the winner field in its bets
		$gamble->fillWinner();
		if (!$gamble->getWinner()) {
			// Process the case of a losing gamble
			$score = $this.calculator->calculateLosingGamble($gamble);
		} 
		$gamble->setPoint($score);
		$gamble->setProcessedDate($date);
	}

	public function apply(Gamble $gamble)
	{
		return $gamble->hasEnded();
	}
}

class EventGambleProcessor implements GambleProcessorInterface
{
	protected $betTypeChain;
	public function __construct(BetTypeChain $betTypeChain)
	{
		$this->betTypeChain = $betTypeChain;
	}

	public function process(Gamble $gamble, Event $event, \DateTime $date)
	{
		$bets = $gamble->findBetsWithEvent($event);
		foreach ($bets as $bet) {
			// Update the winner field in each bet
			$betTypeEntity = $this->betTypeChain->findByEventTypeAndType($event->getType(), $bet->getType());
			$result = $betTypeEntity->processBet($bet);
			if (is_bool($result)) {
				$bet->setWinner($result);
			}
		}
	}

	public function apply(Gamble $gamble)
	{
		return !$gamble->hasEnded();
	}
}

BoardInfo
snId, rdId, groupId
status compute_started, scores_added, compute_finished[ui: pending, complete](started, scoresAdded, positionsUpdated)]
userCount
lastStatusUpdate: 

LeaderBoard
standing=>ssn, rnd, user, score, pos,  preds

sub-> up8Pred -> upd8BoardInfoStatus[use {}] -> up8Snst -> up8Rdst -> up8minis
onComp -> movePos[pushPred]
movePos onlyIf scores_added

http://localhost:3000/matches?league=premier-league&season=16-17&round=2


, {
			fixtureId: "$_id",
			date: "$date",
			result: "$result",
			homeTeam: "$homeTeam",
			awayTeam: "$awayTeam",
			odds: "$odds"
		}